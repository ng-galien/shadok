#!/bin/bash

# Script de test pour les composants avanc√©s de kind
# Usage: ./test-kind-config.sh [cluster-name]

set -euo pipefail

# Configuration
CLUSTER_NAME="${1:-shadok-dev}"

# Couleurs pour les logs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Test de cert-manager
test_cert_manager() {
    log_info "üîê === Test de cert-manager ==="
    
    # V√©rifier que cert-manager est install√©
    if ! kubectl get namespace cert-manager --context "kind-${CLUSTER_NAME}" &> /dev/null; then
        log_error "‚ùå Namespace cert-manager non trouv√©"
        return 1
    fi
    
    # V√©rifier que les pods sont en marche
    local ready_pods=$(kubectl get pods -n cert-manager --context "kind-${CLUSTER_NAME}" \
        --field-selector=status.phase=Running --no-headers 2>/dev/null | wc -l | tr -d ' ')
    
    if [ "$ready_pods" -ge 3 ]; then
        log_success "‚úÖ cert-manager op√©rationnel ($ready_pods pods)"
    else
        log_warning "‚ö†Ô∏è  cert-manager partiellement op√©rationnel ($ready_pods pods)"
    fi
    
    # Tester la cr√©ation d'un certificat
    kubectl apply -f - <<EOF
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: test-cert-temp
  namespace: default
spec:
  secretName: test-cert-temp-secret
  issuerRef:
    name: selfsigned-issuer
    kind: ClusterIssuer
  dnsNames:
  - temp-test.local
EOF
    
    # Attendre un peu et v√©rifier
    sleep 10
    if kubectl get certificate test-cert-temp --context "kind-${CLUSTER_NAME}" -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' | grep -q "True"; then
        log_success "üîí Cr√©ation de certificat fonctionnelle"
    else
        log_warning "‚ö†Ô∏è  Cr√©ation de certificat en cours..."
    fi
    
    # Nettoyer
    kubectl delete certificate test-cert-temp --context "kind-${CLUSTER_NAME}" &> /dev/null || true
    kubectl delete secret test-cert-temp-secret --context "kind-${CLUSTER_NAME}" &> /dev/null || true
    
    return 0
}

# Test d'ingress-nginx avec snippets
test_ingress_nginx() {
    log_info "üåê === Test d'ingress-nginx avec snippets ==="
    
    # V√©rifier que ingress-nginx est install√©
    if ! kubectl get namespace ingress-nginx --context "kind-${CLUSTER_NAME}" &> /dev/null; then
        log_error "‚ùå Namespace ingress-nginx non trouv√©"
        return 1
    fi
    
    # V√©rifier que les pods sont en marche
    local ready_pods=$(kubectl get pods -n ingress-nginx --context "kind-${CLUSTER_NAME}" \
        --selector=app.kubernetes.io/component=controller \
        --field-selector=status.phase=Running --no-headers 2>/dev/null | wc -l | tr -d ' ')
    
    if [ "$ready_pods" -gt 0 ]; then
        log_success "‚úÖ ingress-nginx op√©rationnel ($ready_pods pods)"
    else
        log_error "‚ùå ingress-nginx non op√©rationnel"
        return 1
    fi
    
    # V√©rifier que les snippets sont activ√©s
    local controller_config=$(kubectl get configmap ingress-nginx-controller -n ingress-nginx --context "kind-${CLUSTER_NAME}" -o jsonpath='{.data}' 2>/dev/null || echo "")
    
    if echo "$controller_config" | grep -q "allow-snippet-annotations"; then
        log_success "üîß Snippets activ√©s dans la configuration"
    else
        log_warning "‚ö†Ô∏è  Configuration des snippets non d√©tect√©e"
    fi
    
    # Cr√©er un ingress de test avec snippet
    kubectl apply -f - <<EOF
apiVersion: v1
kind: Service
metadata:
  name: test-service-temp
  namespace: default
spec:
  selector:
    app: curl-test
  ports:
  - port: 80
    targetPort: 8080
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: test-ingress-temp
  namespace: default
  annotations:
    nginx.ingress.kubernetes.io/configuration-snippet: |
      add_header X-Test-Snippet "Hello from snippet" always;
spec:
  ingressClassName: nginx
  rules:
  - host: test-snippet.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: test-service-temp
            port:
              number: 80
EOF
    
    sleep 5
    
    # Tester l'ingress
    if kubectl get ingress test-ingress-temp --context "kind-${CLUSTER_NAME}" &> /dev/null; then
        log_success "üìù Ingress avec snippet cr√©√©"
    else
        log_warning "‚ö†Ô∏è  √âchec de cr√©ation de l'ingress avec snippet"
    fi
    
    # Nettoyer
    kubectl delete ingress test-ingress-temp --context "kind-${CLUSTER_NAME}" &> /dev/null || true
    kubectl delete service test-service-temp --context "kind-${CLUSTER_NAME}" &> /dev/null || true
    
    return 0
}

# Test du Kubernetes Dashboard
test_dashboard() {
    log_info "üìä === Test du Kubernetes Dashboard ==="
    
    # V√©rifier que le dashboard est install√©
    if ! kubectl get namespace kubernetes-dashboard --context "kind-${CLUSTER_NAME}" &> /dev/null; then
        log_error "‚ùå Namespace kubernetes-dashboard non trouv√©"
        return 1
    fi
    
    # V√©rifier que les pods sont en marche
    local ready_pods=$(kubectl get pods -n kubernetes-dashboard --context "kind-${CLUSTER_NAME}" \
        --field-selector=status.phase=Running --no-headers 2>/dev/null | wc -l | tr -d ' ')
    
    if [ "$ready_pods" -gt 0 ]; then
        log_success "‚úÖ Kubernetes Dashboard op√©rationnel ($ready_pods pods)"
    else
        log_error "‚ùå Kubernetes Dashboard non op√©rationnel"
        return 1
    fi
    
    # V√©rifier l'ingress du dashboard
    if kubectl get ingress kubernetes-dashboard -n kubernetes-dashboard --context "kind-${CLUSTER_NAME}" &> /dev/null; then
        log_success "üåê Ingress dashboard configur√©"
        
        # V√©rifier l'annotation du snippet
        local snippet=$(kubectl get ingress kubernetes-dashboard -n kubernetes-dashboard --context "kind-${CLUSTER_NAME}" \
            -o jsonpath='{.metadata.annotations.nginx\.ingress\.kubernetes\.io/configuration-snippet}' 2>/dev/null || echo "")
        
        if echo "$snippet" | grep -q "Authorization"; then
            log_success "üîê Snippet d'auto-login configur√©"
        else
            log_warning "‚ö†Ô∏è  Snippet d'auto-login non d√©tect√©"
        fi
    else
        log_warning "‚ö†Ô∏è  Ingress dashboard non trouv√©"
    fi
    
    # V√©rifier le token d'acc√®s
    if kubectl get secret dashboard-admin-token -n kubernetes-dashboard --context "kind-${CLUSTER_NAME}" &> /dev/null; then
        log_success "üé´ Token d'acc√®s admin cr√©√©"
    else
        log_warning "‚ö†Ô∏è  Token d'acc√®s admin non trouv√©"
    fi
    
    return 0
}

# Test du pod curl
test_curl_pod() {
    log_info "üß™ === Test du pod curl ==="
    
    # V√©rifier que le pod curl existe et est pr√™t
    if kubectl get pod curl-test --context "kind-${CLUSTER_NAME}" &> /dev/null; then
        local pod_status=$(kubectl get pod curl-test --context "kind-${CLUSTER_NAME}" -o jsonpath='{.status.phase}')
        
        if [ "$pod_status" = "Running" ]; then
            log_success "‚úÖ Pod curl-test op√©rationnel"
            
            # Tester une requ√™te interne
            if kubectl exec curl-test --context "kind-${CLUSTER_NAME}" -- curl -s -o /dev/null -w "%{http_code}" \
                http://kubernetes-dashboard-kong-proxy.kubernetes-dashboard.svc.cluster.local 2>/dev/null | grep -q "200\|403\|404"; then
                log_success "üåê Pod curl peut acc√©der aux services internes"
            else
                log_warning "‚ö†Ô∏è  Pod curl ne peut pas acc√©der aux services internes"
            fi
            
            # Tester l'acc√®s externe (DNS)
            if kubectl exec curl-test --context "kind-${CLUSTER_NAME}" -- curl -s -o /dev/null -w "%{http_code}" \
                https://httpbin.org/status/200 2>/dev/null | grep -q "200"; then
                log_success "üåç Pod curl a acc√®s √† Internet"
            else
                log_warning "‚ö†Ô∏è  Pod curl n'a pas acc√®s √† Internet"
            fi
            
        else
            log_error "‚ùå Pod curl-test non op√©rationnel (statut: $pod_status)"
            return 1
        fi
    else
        log_error "‚ùå Pod curl-test non trouv√©"
        return 1
    fi
    
    return 0
}

# Test des certificats
test_certificates() {
    log_info "üîí === Test des certificats ==="
    
    # V√©rifier le ClusterIssuer
    if kubectl get clusterissuer selfsigned-issuer --context "kind-${CLUSTER_NAME}" &> /dev/null; then
        log_success "‚úÖ ClusterIssuer selfsigned-issuer configur√©"
    else
        log_error "‚ùå ClusterIssuer selfsigned-issuer non trouv√©"
        return 1
    fi
    
    # V√©rifier le certificat de test
    if kubectl get certificate test-certificate --context "kind-${CLUSTER_NAME}" &> /dev/null; then
        local cert_status=$(kubectl get certificate test-certificate --context "kind-${CLUSTER_NAME}" \
            -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "Unknown")
        
        if [ "$cert_status" = "True" ]; then
            log_success "üé´ Certificat de test valide et pr√™t"
        else
            log_warning "‚ö†Ô∏è  Certificat de test en cours de cr√©ation (statut: $cert_status)"
        fi
    else
        log_warning "‚ö†Ô∏è  Certificat de test non trouv√©"
    fi
    
    return 0
}

# Test de connectivit√© compl√®te
test_connectivity() {
    log_info "üîó === Test de connectivit√© compl√®te ==="
    
    # Test depuis le pod curl vers le dashboard via l'ingress interne
    log_info "üß™ Test d'acc√®s au dashboard via ingress..."
    
    # Ajouter une entr√©e temporaire dans /etc/hosts du pod curl
    kubectl exec curl-test --context "kind-${CLUSTER_NAME}" -- sh -c "echo '127.0.0.1 dashboard.local' >> /etc/hosts" 2>/dev/null || true
    
    # Test d'acc√®s au dashboard (peut √©chouer si pas de /etc/hosts configur√© sur l'h√¥te)
    local response=$(kubectl exec curl-test --context "kind-${CLUSTER_NAME}" -- \
        curl -s -o /dev/null -w "%{http_code}" http://dashboard.local 2>/dev/null || echo "000")
    
    if [ "$response" = "200" ] || [ "$response" = "403" ] || [ "$response" = "404" ]; then
        log_success "üéØ Acc√®s au dashboard via ingress fonctionnel (HTTP $response)"
    else
        log_warning "‚ö†Ô∏è  Acc√®s au dashboard via ingress non fonctionnel (HTTP $response)"
        log_info "   Ajoutez '127.0.0.1 dashboard.local' √† /etc/hosts de l'h√¥te"
    fi
    
    return 0
}

# Afficher le r√©sum√© des tests
show_test_summary() {
    local cert_manager_ok=$1
    local ingress_ok=$2
    local dashboard_ok=$3
    local curl_ok=$4
    local certificates_ok=$5
    
    log_info "üìä === R√©sum√© des tests de configuration ==="
    [ "$cert_manager_ok" -eq 0 ] && log_success "‚úÖ cert-manager" || log_error "‚ùå cert-manager"
    [ "$ingress_ok" -eq 0 ] && log_success "‚úÖ ingress-nginx (avec snippets)" || log_error "‚ùå ingress-nginx"
    [ "$dashboard_ok" -eq 0 ] && log_success "‚úÖ Kubernetes Dashboard" || log_error "‚ùå Kubernetes Dashboard"
    [ "$curl_ok" -eq 0 ] && log_success "‚úÖ Pod curl-test" || log_error "‚ùå Pod curl-test"
    [ "$certificates_ok" -eq 0 ] && log_success "‚úÖ Certificats" || log_error "‚ùå Certificats"
    
    echo ""
    if [ "$cert_manager_ok" -eq 0 ] && [ "$ingress_ok" -eq 0 ] && [ "$dashboard_ok" -eq 0 ] && [ "$curl_ok" -eq 0 ] && [ "$certificates_ok" -eq 0 ]; then
        log_success "üéâ Tous les composants avanc√©s sont op√©rationnels !"
        echo "   ‚ú® Le cluster kind est compl√®tement configur√© et pr√™t √† l'emploi."
        echo ""
        log_info "üåê Acc√®s disponibles:"
        echo "   - Dashboard: http://dashboard.local"
        echo "   - Tests: kubectl exec -it curl-test -- sh"
        echo ""
        log_info "üîß Configuration /etc/hosts requise:"
        echo "   echo '127.0.0.1 dashboard.local test.local' | sudo tee -a /etc/hosts"
    else
        log_error "üí• Certains composants ont des probl√®mes"
        echo "   üîç V√©rifiez les logs ci-dessus pour diagnostiquer."
        echo "   üîß Relancez la configuration: ./kind-config.sh ${CLUSTER_NAME}"
    fi
}

# Fonction principale
main() {
    log_info "üß™ === Tests de configuration avanc√©e kind '${CLUSTER_NAME}' ==="
    echo ""
    
    # V√©rifier si le cluster existe
    if ! kind get clusters | grep -q "^${CLUSTER_NAME}$"; then
        log_error "‚ùå Cluster kind '${CLUSTER_NAME}' non trouv√©"
        echo "   üöÄ Cr√©ez le cluster avec ./start-kind.sh"
        exit 1
    fi
    
    local cert_manager_result=1
    local ingress_result=1
    local dashboard_result=1
    local curl_result=1
    local certificates_result=1
    
    # Ex√©cuter les tests
    test_cert_manager && cert_manager_result=0
    echo ""
    
    test_ingress_nginx && ingress_result=0
    echo ""
    
    test_dashboard && dashboard_result=0
    echo ""
    
    test_curl_pod && curl_result=0
    echo ""
    
    test_certificates && certificates_result=0
    echo ""
    
    test_connectivity
    echo ""
    
    # Afficher le r√©sum√©
    show_test_summary $cert_manager_result $ingress_result $dashboard_result $curl_result $certificates_result
    
    # Code de sortie bas√© sur les r√©sultats
    if [ "$cert_manager_result" -eq 0 ] && [ "$ingress_result" -eq 0 ] && [ "$dashboard_result" -eq 0 ] && [ "$curl_result" -eq 0 ] && [ "$certificates_result" -eq 0 ]; then
        exit 0
    else
        exit 1
    fi
}

# Ex√©cuter le script principal
main "$@"
